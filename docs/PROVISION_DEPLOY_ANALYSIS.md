# Provision & Deploy Issue Analysis

## Problem
Both `provision` and `deploy` actions have NEVER worked in the Go application, despite the bash script `./deploy.sh` working perfectly.

## Root Cause

### The Issue
The Go application generates an **inventory structure per environment** in `inventory/{env}/`, but the bash script `./deploy.sh` expects to use the **GLOBAL `group_vars/all.yml`** that exists at the repository root.

### What Happens

#### Bash Script Workflow (✅ Works)
```bash
./deploy.sh provision docker
```
1. Uses inventory at: `inventory/docker/hosts.yml`
2. **Uses GLOBAL group_vars**: `group_vars/all.yml` (at root)
3. Ansible merges: root `group_vars/` + environment `inventory/docker/`
4. All variables are available ✅

#### Go Application Workflow (❌ Broken)
```
ScriptExecutor.RunAction("provision", "docker-web-01", ...)
```
1. Calls: `./deploy.sh provision docker --yes`
2. Uses inventory at: `inventory/docker/hosts.yml`
3. **Tries to use**: `inventory/docker/group_vars/all.yml` (generated by Go)
4. **Missing from global**: `group_vars/all.yml` is IGNORED
5. Result: Ansible variables incomplete, provision/deploy fail ❌

### The Critical Difference

**Bash Script Expects:**
```
boiler-deploy/
├── group_vars/
│   └── all.yml              ← GLOBAL variables (used by bash script)
├── inventory/
│   └── docker/
│       └── hosts.yml
```

**Go App Generates:**
```
boiler-deploy/
├── group_vars/
│   └── all.yml              ← EXISTS but NOT READ when using env-specific inventory
├── inventory/
│   └── docker/
│       ├── hosts.yml
│       └── group_vars/
│           └── all.yml      ← Generated by Go, used INSTEAD of global one
```

### Why It's Broken

When you run:
```bash
ansible-playbook -i inventory/docker playbooks/provision.yml
```

Ansible's variable precedence:
1. ✅ Reads `inventory/docker/hosts.yml` 
2. ✅ Reads `inventory/docker/group_vars/all.yml` (generated by Go)
3. ❌ **IGNORES** root-level `group_vars/all.yml`

The playbooks expect certain variables from the global `group_vars/all.yml` that are **NOT** in the generated `inventory/docker/group_vars/all.yml`.

### Missing Variables

Comparing the files:

**Global `group_vars/all.yml`** (root):
```yaml
ssh_key_path: "/home/basthook/.ssh/Hosting.pub"  ← Missing in generated!
timezone: "Europe/Paris"                          ← Missing in generated!
pm2_max_memory: "512M"                            ← Has quotes
```

**Generated `inventory/docker/group_vars/all.yml`**:
```yaml
# ssh_key_path: NOT PRESENT
# timezone: CONDITIONALLY ADDED (can be empty)
pm2_max_memory: 512M                              ← NO quotes (might break)
```

## Solutions

### Option 1: Use Ansible's Inventory Path Correctly (RECOMMENDED)
Instead of using `-i inventory/docker`, use `-i inventory/docker/hosts.yml` AND ensure Ansible reads the root `group_vars/`.

**Problem**: Ansible doesn't automatically traverse up to find root `group_vars/` when using a file path.

### Option 2: Copy Global Variables to Each Environment
Merge root `group_vars/all.yml` into each generated `inventory/{env}/group_vars/all.yml`.

**Modification needed**: Update `generator.go` to include ALL variables from global config.

### Option 3: Use Ansible Config to Set Variables Path
Create `ansible.cfg` that points to root-level `group_vars/`:

```ini
[defaults]
inventory = ./inventory/docker
group_vars = ./group_vars
```

### Option 4: Use Script with Correct Working Directory
Ensure `deploy.sh` is called from repository root with relative paths.

**Current Go code**:
```go
cmd := exec.Command(e.scriptPath, action, e.environment, "--yes")
cmd.Dir = "." // Already set to root
```

This should work but might have PATH issues.

## Recommended Fix

### Short-term Fix (Immediate)
Update `script_executor.go` to ensure proper working directory and inventory structure:

```go
func (e *ScriptExecutor) RunAction(action string, serverName string, outputChan chan<- string) (*ExecutionResult, error) {
    // ... existing code ...
    
    // Get absolute path to script
    scriptPath, _ := filepath.Abs(e.scriptPath)
    workDir, _ := filepath.Abs(".")
    
    cmd := exec.Command(scriptPath, action, e.environment, "--yes")
    cmd.Dir = workDir
    
    // Ensure ANSIBLE picks up root group_vars
    cmd.Env = append(os.Environ(), 
        "ANSIBLE_INVENTORY="+filepath.Join(workDir, "inventory", e.environment),
    )
    
    // ... rest of code ...
}
```

### Long-term Fix (Proper Solution)
Merge global and environment-specific variables in `generator.go`:

1. Read root `group_vars/all.yml`
2. Merge with environment-specific variables
3. Save merged result to `inventory/{env}/group_vars/all.yml`

This ensures each environment is self-contained and has ALL required variables.

## Testing Commands

```bash
# Test bash script directly (works)
./deploy.sh provision docker

# Test ansible directly with generated inventory (should fail)
ansible-playbook -i inventory/docker playbooks/provision.yml

# Test ansible with correct inventory path (should work?)
ansible-playbook -i inventory/docker/hosts.yml playbooks/provision.yml --inventory-dir=inventory/docker

# Debug variable precedence
ansible-inventory -i inventory/docker --list --yaml
```

## Conclusion

The Go app generates valid Ansible inventory structures, but they're **incomplete** compared to what `deploy.sh` expects. The bash script relies on the root-level `group_vars/all.yml` which gets ignored when using environment-specific inventory paths.

**Fix**: Either ensure the generated `group_vars/` includes ALL variables OR modify how we invoke Ansible to read both root and environment-specific variables.
